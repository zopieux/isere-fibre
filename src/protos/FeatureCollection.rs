// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `FeatureCollection.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer {
    // message fields
    pub version: ::std::string::String,
    pub queryResult: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_QueryResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer {
    fn default() -> &'a FeatureCollectionPBuffer {
        <FeatureCollectionPBuffer as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer {
    pub fn new() -> FeatureCollectionPBuffer {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.QueryResult queryResult = 2;


    pub fn get_queryResult(&self) -> &FeatureCollectionPBuffer_QueryResult {
        self.queryResult.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_QueryResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_queryResult(&mut self) {
        self.queryResult.clear();
    }

    pub fn has_queryResult(&self) -> bool {
        self.queryResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryResult(&mut self, v: FeatureCollectionPBuffer_QueryResult) {
        self.queryResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queryResult(&mut self) -> &mut FeatureCollectionPBuffer_QueryResult {
        if self.queryResult.is_none() {
            self.queryResult.set_default();
        }
        self.queryResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_queryResult(&mut self) -> FeatureCollectionPBuffer_QueryResult {
        self.queryResult.take().unwrap_or_else(|| FeatureCollectionPBuffer_QueryResult::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer {
    fn is_initialized(&self) -> bool {
        for v in &self.queryResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.queryResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if let Some(ref v) = self.queryResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if let Some(ref v) = self.queryResult.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer {
        FeatureCollectionPBuffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &FeatureCollectionPBuffer| { &m.version },
                |m: &mut FeatureCollectionPBuffer| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_QueryResult>>(
                "queryResult",
                |m: &FeatureCollectionPBuffer| { &m.queryResult },
                |m: &mut FeatureCollectionPBuffer| { &mut m.queryResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer>(
                "FeatureCollectionPBuffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer {
    fn clear(&mut self) {
        self.version.clear();
        self.queryResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_SpatialReference {
    // message fields
    pub wkid: u32,
    pub lastestWkid: u32,
    pub vcsWkid: u32,
    pub latestVcsWkid: u32,
    pub wkt: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_SpatialReference {
    fn default() -> &'a FeatureCollectionPBuffer_SpatialReference {
        <FeatureCollectionPBuffer_SpatialReference as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_SpatialReference {
    pub fn new() -> FeatureCollectionPBuffer_SpatialReference {
        ::std::default::Default::default()
    }

    // uint32 wkid = 1;


    pub fn get_wkid(&self) -> u32 {
        self.wkid
    }
    pub fn clear_wkid(&mut self) {
        self.wkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wkid(&mut self, v: u32) {
        self.wkid = v;
    }

    // uint32 lastestWkid = 2;


    pub fn get_lastestWkid(&self) -> u32 {
        self.lastestWkid
    }
    pub fn clear_lastestWkid(&mut self) {
        self.lastestWkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastestWkid(&mut self, v: u32) {
        self.lastestWkid = v;
    }

    // uint32 vcsWkid = 3;


    pub fn get_vcsWkid(&self) -> u32 {
        self.vcsWkid
    }
    pub fn clear_vcsWkid(&mut self) {
        self.vcsWkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_vcsWkid(&mut self, v: u32) {
        self.vcsWkid = v;
    }

    // uint32 latestVcsWkid = 4;


    pub fn get_latestVcsWkid(&self) -> u32 {
        self.latestVcsWkid
    }
    pub fn clear_latestVcsWkid(&mut self) {
        self.latestVcsWkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestVcsWkid(&mut self, v: u32) {
        self.latestVcsWkid = v;
    }

    // string wkt = 5;


    pub fn get_wkt(&self) -> &str {
        &self.wkt
    }
    pub fn clear_wkt(&mut self) {
        self.wkt.clear();
    }

    // Param is passed by value, moved
    pub fn set_wkt(&mut self, v: ::std::string::String) {
        self.wkt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wkt(&mut self) -> &mut ::std::string::String {
        &mut self.wkt
    }

    // Take field
    pub fn take_wkt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wkt, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_SpatialReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wkid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lastestWkid = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vcsWkid = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latestVcsWkid = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wkt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wkid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.wkid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastestWkid != 0 {
            my_size += ::protobuf::rt::value_size(2, self.lastestWkid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vcsWkid != 0 {
            my_size += ::protobuf::rt::value_size(3, self.vcsWkid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latestVcsWkid != 0 {
            my_size += ::protobuf::rt::value_size(4, self.latestVcsWkid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.wkt.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.wkt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.wkid != 0 {
            os.write_uint32(1, self.wkid)?;
        }
        if self.lastestWkid != 0 {
            os.write_uint32(2, self.lastestWkid)?;
        }
        if self.vcsWkid != 0 {
            os.write_uint32(3, self.vcsWkid)?;
        }
        if self.latestVcsWkid != 0 {
            os.write_uint32(4, self.latestVcsWkid)?;
        }
        if !self.wkt.is_empty() {
            os.write_string(5, &self.wkt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_SpatialReference {
        FeatureCollectionPBuffer_SpatialReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "wkid",
                |m: &FeatureCollectionPBuffer_SpatialReference| { &m.wkid },
                |m: &mut FeatureCollectionPBuffer_SpatialReference| { &mut m.wkid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lastestWkid",
                |m: &FeatureCollectionPBuffer_SpatialReference| { &m.lastestWkid },
                |m: &mut FeatureCollectionPBuffer_SpatialReference| { &mut m.lastestWkid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vcsWkid",
                |m: &FeatureCollectionPBuffer_SpatialReference| { &m.vcsWkid },
                |m: &mut FeatureCollectionPBuffer_SpatialReference| { &mut m.vcsWkid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "latestVcsWkid",
                |m: &FeatureCollectionPBuffer_SpatialReference| { &m.latestVcsWkid },
                |m: &mut FeatureCollectionPBuffer_SpatialReference| { &mut m.latestVcsWkid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wkt",
                |m: &FeatureCollectionPBuffer_SpatialReference| { &m.wkt },
                |m: &mut FeatureCollectionPBuffer_SpatialReference| { &mut m.wkt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_SpatialReference>(
                "FeatureCollectionPBuffer.SpatialReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_SpatialReference {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_SpatialReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_SpatialReference::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_SpatialReference {
    fn clear(&mut self) {
        self.wkid = 0;
        self.lastestWkid = 0;
        self.vcsWkid = 0;
        self.latestVcsWkid = 0;
        self.wkt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_SpatialReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_SpatialReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Field {
    // message fields
    pub name: ::std::string::String,
    pub fieldType: FeatureCollectionPBuffer_FieldType,
    pub alias: ::std::string::String,
    pub sqlType: FeatureCollectionPBuffer_SQLType,
    pub domain: ::std::string::String,
    pub defaultValue: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Field {
    fn default() -> &'a FeatureCollectionPBuffer_Field {
        <FeatureCollectionPBuffer_Field as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_Field {
    pub fn new() -> FeatureCollectionPBuffer_Field {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.FieldType fieldType = 2;


    pub fn get_fieldType(&self) -> FeatureCollectionPBuffer_FieldType {
        self.fieldType
    }
    pub fn clear_fieldType(&mut self) {
        self.fieldType = FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger;
    }

    // Param is passed by value, moved
    pub fn set_fieldType(&mut self, v: FeatureCollectionPBuffer_FieldType) {
        self.fieldType = v;
    }

    // string alias = 3;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.SQLType sqlType = 4;


    pub fn get_sqlType(&self) -> FeatureCollectionPBuffer_SQLType {
        self.sqlType
    }
    pub fn clear_sqlType(&mut self) {
        self.sqlType = FeatureCollectionPBuffer_SQLType::sqlTypeBigInt;
    }

    // Param is passed by value, moved
    pub fn set_sqlType(&mut self, v: FeatureCollectionPBuffer_SQLType) {
        self.sqlType = v;
    }

    // string domain = 5;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // string defaultValue = 6;


    pub fn get_defaultValue(&self) -> &str {
        &self.defaultValue
    }
    pub fn clear_defaultValue(&mut self) {
        self.defaultValue.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultValue(&mut self, v: ::std::string::String) {
        self.defaultValue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultValue(&mut self) -> &mut ::std::string::String {
        &mut self.defaultValue
    }

    // Take field
    pub fn take_defaultValue(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.defaultValue, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Field {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fieldType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sqlType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.defaultValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.fieldType != FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger {
            my_size += ::protobuf::rt::enum_size(2, self.fieldType);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        if self.sqlType != FeatureCollectionPBuffer_SQLType::sqlTypeBigInt {
            my_size += ::protobuf::rt::enum_size(4, self.sqlType);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.domain);
        }
        if !self.defaultValue.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.defaultValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.fieldType != FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.fieldType))?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        if self.sqlType != FeatureCollectionPBuffer_SQLType::sqlTypeBigInt {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.sqlType))?;
        }
        if !self.domain.is_empty() {
            os.write_string(5, &self.domain)?;
        }
        if !self.defaultValue.is_empty() {
            os.write_string(6, &self.defaultValue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Field {
        FeatureCollectionPBuffer_Field::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FeatureCollectionPBuffer_Field| { &m.name },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureCollectionPBuffer_FieldType>>(
                "fieldType",
                |m: &FeatureCollectionPBuffer_Field| { &m.fieldType },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.fieldType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &FeatureCollectionPBuffer_Field| { &m.alias },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureCollectionPBuffer_SQLType>>(
                "sqlType",
                |m: &FeatureCollectionPBuffer_Field| { &m.sqlType },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.sqlType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domain",
                |m: &FeatureCollectionPBuffer_Field| { &m.domain },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.domain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "defaultValue",
                |m: &FeatureCollectionPBuffer_Field| { &m.defaultValue },
                |m: &mut FeatureCollectionPBuffer_Field| { &mut m.defaultValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Field>(
                "FeatureCollectionPBuffer.Field",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Field {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Field> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Field::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Field {
    fn clear(&mut self) {
        self.name.clear();
        self.fieldType = FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger;
        self.alias.clear();
        self.sqlType = FeatureCollectionPBuffer_SQLType::sqlTypeBigInt;
        self.domain.clear();
        self.defaultValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Field {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Value {
    // message oneof groups
    pub value_type: ::std::option::Option<FeatureCollectionPBuffer_Value_oneof_value_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Value {
    fn default() -> &'a FeatureCollectionPBuffer_Value {
        <FeatureCollectionPBuffer_Value as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeatureCollectionPBuffer_Value_oneof_value_type {
    string_value(::std::string::String),
    float_value(f32),
    double_value(f64),
    sint_value(i32),
    uint_value(u32),
    int64_value(i64),
    uint64_value(u64),
    sint64_value(i64),
    bool_value(bool),
}

impl FeatureCollectionPBuffer_Value {
    pub fn new() -> FeatureCollectionPBuffer_Value {
        ::std::default::Default::default()
    }

    // string string_value = 1;


    pub fn get_string_value(&self) -> &str {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(_)) = self.value_type {
        } else {
            self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(::std::string::String::new()));
        }
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value_type.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // float float_value = 2;


    pub fn get_float_value(&self) -> f32 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::float_value(v))
    }

    // double double_value = 3;


    pub fn get_double_value(&self) -> f64 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::double_value(v))
    }

    // sint32 sint_value = 4;


    pub fn get_sint_value(&self) -> i32 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sint_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_sint_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint_value(&mut self, v: i32) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(v))
    }

    // uint32 uint_value = 5;


    pub fn get_uint_value(&self) -> u32 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_uint_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_uint_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint_value(&mut self, v: u32) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(v))
    }

    // int64 int64_value = 6;


    pub fn get_int64_value(&self) -> i64 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int64_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_int64_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64_value(&mut self, v: i64) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(v))
    }

    // uint64 uint64_value = 7;


    pub fn get_uint64_value(&self) -> u64 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_uint64_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_uint64_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint64_value(&mut self, v: u64) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(v))
    }

    // sint64 sint64_value = 8;


    pub fn get_sint64_value(&self) -> i64 {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sint64_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_sint64_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint64_value(&mut self, v: i64) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(v))
    }

    // bool bool_value = 9;


    pub fn get_bool_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(v))
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::string_value(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::float_value(is.read_float()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::double_value(is.read_double()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(is.read_sint32()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(is.read_uint32()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(is.read_int64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(is.read_uint64()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(is.read_sint64()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_type = ::std::option::Option::Some(FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value_type {
            match v {
                &FeatureCollectionPBuffer_Value_oneof_value_type::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::float_value(v) => {
                    my_size += 5;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::double_value(v) => {
                    my_size += 9;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value_type {
            match v {
                &FeatureCollectionPBuffer_Value_oneof_value_type::string_value(ref v) => {
                    os.write_string(1, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::float_value(v) => {
                    os.write_float(2, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::double_value(v) => {
                    os.write_double(3, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::sint_value(v) => {
                    os.write_sint32(4, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::uint_value(v) => {
                    os.write_uint32(5, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::int64_value(v) => {
                    os.write_int64(6, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::uint64_value(v) => {
                    os.write_uint64(7, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::sint64_value(v) => {
                    os.write_sint64(8, v)?;
                },
                &FeatureCollectionPBuffer_Value_oneof_value_type::bool_value(v) => {
                    os.write_bool(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Value {
        FeatureCollectionPBuffer_Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                FeatureCollectionPBuffer_Value::has_string_value,
                FeatureCollectionPBuffer_Value::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                FeatureCollectionPBuffer_Value::has_float_value,
                FeatureCollectionPBuffer_Value::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                FeatureCollectionPBuffer_Value::has_double_value,
                FeatureCollectionPBuffer_Value::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "sint_value",
                FeatureCollectionPBuffer_Value::has_sint_value,
                FeatureCollectionPBuffer_Value::get_sint_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "uint_value",
                FeatureCollectionPBuffer_Value::has_uint_value,
                FeatureCollectionPBuffer_Value::get_uint_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "int64_value",
                FeatureCollectionPBuffer_Value::has_int64_value,
                FeatureCollectionPBuffer_Value::get_int64_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "uint64_value",
                FeatureCollectionPBuffer_Value::has_uint64_value,
                FeatureCollectionPBuffer_Value::get_uint64_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "sint64_value",
                FeatureCollectionPBuffer_Value::has_sint64_value,
                FeatureCollectionPBuffer_Value::get_sint64_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "bool_value",
                FeatureCollectionPBuffer_Value::has_bool_value,
                FeatureCollectionPBuffer_Value::get_bool_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Value>(
                "FeatureCollectionPBuffer.Value",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Value {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Value> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Value::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Value {
    fn clear(&mut self) {
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Geometry {
    // message fields
    pub lengths: ::std::vec::Vec<u32>,
    pub coords: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Geometry {
    fn default() -> &'a FeatureCollectionPBuffer_Geometry {
        <FeatureCollectionPBuffer_Geometry as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_Geometry {
    pub fn new() -> FeatureCollectionPBuffer_Geometry {
        ::std::default::Default::default()
    }

    // repeated uint32 lengths = 2;


    pub fn get_lengths(&self) -> &[u32] {
        &self.lengths
    }
    pub fn clear_lengths(&mut self) {
        self.lengths.clear();
    }

    // Param is passed by value, moved
    pub fn set_lengths(&mut self, v: ::std::vec::Vec<u32>) {
        self.lengths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lengths(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.lengths
    }

    // Take field
    pub fn take_lengths(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.lengths, ::std::vec::Vec::new())
    }

    // repeated sint64 coords = 3;


    pub fn get_coords(&self) -> &[i64] {
        &self.coords
    }
    pub fn clear_coords(&mut self) {
        self.coords.clear();
    }

    // Param is passed by value, moved
    pub fn set_coords(&mut self, v: ::std::vec::Vec<i64>) {
        self.coords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_coords(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.coords
    }

    // Take field
    pub fn take_coords(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.coords, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Geometry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.lengths)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.coords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lengths.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.lengths);
        }
        if !self.coords.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(3, &self.coords);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.lengths.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.lengths))?;
            for v in &self.lengths {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.coords.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.coords))?;
            for v in &self.coords {
                os.write_sint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Geometry {
        FeatureCollectionPBuffer_Geometry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lengths",
                |m: &FeatureCollectionPBuffer_Geometry| { &m.lengths },
                |m: &mut FeatureCollectionPBuffer_Geometry| { &mut m.lengths },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "coords",
                |m: &FeatureCollectionPBuffer_Geometry| { &m.coords },
                |m: &mut FeatureCollectionPBuffer_Geometry| { &mut m.coords },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Geometry>(
                "FeatureCollectionPBuffer.Geometry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Geometry {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Geometry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Geometry::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Geometry {
    fn clear(&mut self) {
        self.lengths.clear();
        self.coords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Geometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Geometry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_esriShapeBuffer {
    // message fields
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_esriShapeBuffer {
    fn default() -> &'a FeatureCollectionPBuffer_esriShapeBuffer {
        <FeatureCollectionPBuffer_esriShapeBuffer as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_esriShapeBuffer {
    pub fn new() -> FeatureCollectionPBuffer_esriShapeBuffer {
        ::std::default::Default::default()
    }

    // bytes bytes = 1;


    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_esriShapeBuffer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bytes.is_empty() {
            os.write_bytes(1, &self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_esriShapeBuffer {
        FeatureCollectionPBuffer_esriShapeBuffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bytes",
                |m: &FeatureCollectionPBuffer_esriShapeBuffer| { &m.bytes },
                |m: &mut FeatureCollectionPBuffer_esriShapeBuffer| { &mut m.bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_esriShapeBuffer>(
                "FeatureCollectionPBuffer.esriShapeBuffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_esriShapeBuffer {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_esriShapeBuffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_esriShapeBuffer::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_esriShapeBuffer {
    fn clear(&mut self) {
        self.bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_esriShapeBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_esriShapeBuffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Feature {
    // message fields
    pub attributes: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value>,
    pub centroid: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_Geometry>,
    // message oneof groups
    pub compressed_geometry: ::std::option::Option<FeatureCollectionPBuffer_Feature_oneof_compressed_geometry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Feature {
    fn default() -> &'a FeatureCollectionPBuffer_Feature {
        <FeatureCollectionPBuffer_Feature as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeatureCollectionPBuffer_Feature_oneof_compressed_geometry {
    geometry(FeatureCollectionPBuffer_Geometry),
    shapeBuffer(FeatureCollectionPBuffer_esriShapeBuffer),
}

impl FeatureCollectionPBuffer_Feature {
    pub fn new() -> FeatureCollectionPBuffer_Feature {
        ::std::default::Default::default()
    }

    // repeated .esriPBuffer.FeatureCollectionPBuffer.Value attributes = 1;


    pub fn get_attributes(&self) -> &[FeatureCollectionPBuffer_Value] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.Geometry geometry = 2;


    pub fn get_geometry(&self) -> &FeatureCollectionPBuffer_Geometry {
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(ref v)) => v,
            _ => <FeatureCollectionPBuffer_Geometry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_geometry(&mut self) {
        self.compressed_geometry = ::std::option::Option::None;
    }

    pub fn has_geometry(&self) -> bool {
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: FeatureCollectionPBuffer_Geometry) {
        self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_geometry(&mut self) -> &mut FeatureCollectionPBuffer_Geometry {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(_)) = self.compressed_geometry {
        } else {
            self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(FeatureCollectionPBuffer_Geometry::new()));
        }
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_geometry(&mut self) -> FeatureCollectionPBuffer_Geometry {
        if self.has_geometry() {
            match self.compressed_geometry.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureCollectionPBuffer_Geometry::new()
        }
    }

    // .esriPBuffer.FeatureCollectionPBuffer.esriShapeBuffer shapeBuffer = 3;


    pub fn get_shapeBuffer(&self) -> &FeatureCollectionPBuffer_esriShapeBuffer {
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(ref v)) => v,
            _ => <FeatureCollectionPBuffer_esriShapeBuffer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shapeBuffer(&mut self) {
        self.compressed_geometry = ::std::option::Option::None;
    }

    pub fn has_shapeBuffer(&self) -> bool {
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shapeBuffer(&mut self, v: FeatureCollectionPBuffer_esriShapeBuffer) {
        self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shapeBuffer(&mut self) -> &mut FeatureCollectionPBuffer_esriShapeBuffer {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(_)) = self.compressed_geometry {
        } else {
            self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(FeatureCollectionPBuffer_esriShapeBuffer::new()));
        }
        match self.compressed_geometry {
            ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shapeBuffer(&mut self) -> FeatureCollectionPBuffer_esriShapeBuffer {
        if self.has_shapeBuffer() {
            match self.compressed_geometry.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureCollectionPBuffer_esriShapeBuffer::new()
        }
    }

    // .esriPBuffer.FeatureCollectionPBuffer.Geometry centroid = 4;


    pub fn get_centroid(&self) -> &FeatureCollectionPBuffer_Geometry {
        self.centroid.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_Geometry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_centroid(&mut self) {
        self.centroid.clear();
    }

    pub fn has_centroid(&self) -> bool {
        self.centroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_centroid(&mut self, v: FeatureCollectionPBuffer_Geometry) {
        self.centroid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_centroid(&mut self) -> &mut FeatureCollectionPBuffer_Geometry {
        if self.centroid.is_none() {
            self.centroid.set_default();
        }
        self.centroid.as_mut().unwrap()
    }

    // Take field
    pub fn take_centroid(&mut self) -> FeatureCollectionPBuffer_Geometry {
        self.centroid.take().unwrap_or_else(|| FeatureCollectionPBuffer_Geometry::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Feature {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(ref v)) = self.compressed_geometry {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(ref v)) = self.compressed_geometry {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.centroid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compressed_geometry = ::std::option::Option::Some(FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.centroid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.centroid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.compressed_geometry {
            match v {
                &FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attributes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.centroid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.compressed_geometry {
            match v {
                &FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::geometry(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FeatureCollectionPBuffer_Feature_oneof_compressed_geometry::shapeBuffer(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Feature {
        FeatureCollectionPBuffer_Feature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Value>>(
                "attributes",
                |m: &FeatureCollectionPBuffer_Feature| { &m.attributes },
                |m: &mut FeatureCollectionPBuffer_Feature| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FeatureCollectionPBuffer_Geometry>(
                "geometry",
                FeatureCollectionPBuffer_Feature::has_geometry,
                FeatureCollectionPBuffer_Feature::get_geometry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FeatureCollectionPBuffer_esriShapeBuffer>(
                "shapeBuffer",
                FeatureCollectionPBuffer_Feature::has_shapeBuffer,
                FeatureCollectionPBuffer_Feature::get_shapeBuffer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Geometry>>(
                "centroid",
                |m: &FeatureCollectionPBuffer_Feature| { &m.centroid },
                |m: &mut FeatureCollectionPBuffer_Feature| { &mut m.centroid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Feature>(
                "FeatureCollectionPBuffer.Feature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Feature {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Feature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Feature::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Feature {
    fn clear(&mut self) {
        self.attributes.clear();
        self.compressed_geometry = ::std::option::Option::None;
        self.compressed_geometry = ::std::option::Option::None;
        self.centroid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Feature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Feature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_UniqueIdField {
    // message fields
    pub name: ::std::string::String,
    pub isSystemMaintained: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_UniqueIdField {
    fn default() -> &'a FeatureCollectionPBuffer_UniqueIdField {
        <FeatureCollectionPBuffer_UniqueIdField as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_UniqueIdField {
    pub fn new() -> FeatureCollectionPBuffer_UniqueIdField {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool isSystemMaintained = 2;


    pub fn get_isSystemMaintained(&self) -> bool {
        self.isSystemMaintained
    }
    pub fn clear_isSystemMaintained(&mut self) {
        self.isSystemMaintained = false;
    }

    // Param is passed by value, moved
    pub fn set_isSystemMaintained(&mut self, v: bool) {
        self.isSystemMaintained = v;
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_UniqueIdField {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isSystemMaintained = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.isSystemMaintained != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.isSystemMaintained != false {
            os.write_bool(2, self.isSystemMaintained)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_UniqueIdField {
        FeatureCollectionPBuffer_UniqueIdField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FeatureCollectionPBuffer_UniqueIdField| { &m.name },
                |m: &mut FeatureCollectionPBuffer_UniqueIdField| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isSystemMaintained",
                |m: &FeatureCollectionPBuffer_UniqueIdField| { &m.isSystemMaintained },
                |m: &mut FeatureCollectionPBuffer_UniqueIdField| { &mut m.isSystemMaintained },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_UniqueIdField>(
                "FeatureCollectionPBuffer.UniqueIdField",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_UniqueIdField {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_UniqueIdField> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_UniqueIdField::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_UniqueIdField {
    fn clear(&mut self) {
        self.name.clear();
        self.isSystemMaintained = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_UniqueIdField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_UniqueIdField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_GeometryProperties {
    // message fields
    pub shapeAreaFieldName: ::std::string::String,
    pub shapeLengthFieldName: ::std::string::String,
    pub units: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_GeometryProperties {
    fn default() -> &'a FeatureCollectionPBuffer_GeometryProperties {
        <FeatureCollectionPBuffer_GeometryProperties as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_GeometryProperties {
    pub fn new() -> FeatureCollectionPBuffer_GeometryProperties {
        ::std::default::Default::default()
    }

    // string shapeAreaFieldName = 1;


    pub fn get_shapeAreaFieldName(&self) -> &str {
        &self.shapeAreaFieldName
    }
    pub fn clear_shapeAreaFieldName(&mut self) {
        self.shapeAreaFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapeAreaFieldName(&mut self, v: ::std::string::String) {
        self.shapeAreaFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shapeAreaFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.shapeAreaFieldName
    }

    // Take field
    pub fn take_shapeAreaFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shapeAreaFieldName, ::std::string::String::new())
    }

    // string shapeLengthFieldName = 2;


    pub fn get_shapeLengthFieldName(&self) -> &str {
        &self.shapeLengthFieldName
    }
    pub fn clear_shapeLengthFieldName(&mut self) {
        self.shapeLengthFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapeLengthFieldName(&mut self, v: ::std::string::String) {
        self.shapeLengthFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shapeLengthFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.shapeLengthFieldName
    }

    // Take field
    pub fn take_shapeLengthFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shapeLengthFieldName, ::std::string::String::new())
    }

    // string units = 3;


    pub fn get_units(&self) -> &str {
        &self.units
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::std::string::String) {
        self.units = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut ::std::string::String {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.units, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_GeometryProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shapeAreaFieldName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shapeLengthFieldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.shapeAreaFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.shapeAreaFieldName);
        }
        if !self.shapeLengthFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.shapeLengthFieldName);
        }
        if !self.units.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.units);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.shapeAreaFieldName.is_empty() {
            os.write_string(1, &self.shapeAreaFieldName)?;
        }
        if !self.shapeLengthFieldName.is_empty() {
            os.write_string(2, &self.shapeLengthFieldName)?;
        }
        if !self.units.is_empty() {
            os.write_string(3, &self.units)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_GeometryProperties {
        FeatureCollectionPBuffer_GeometryProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shapeAreaFieldName",
                |m: &FeatureCollectionPBuffer_GeometryProperties| { &m.shapeAreaFieldName },
                |m: &mut FeatureCollectionPBuffer_GeometryProperties| { &mut m.shapeAreaFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shapeLengthFieldName",
                |m: &FeatureCollectionPBuffer_GeometryProperties| { &m.shapeLengthFieldName },
                |m: &mut FeatureCollectionPBuffer_GeometryProperties| { &mut m.shapeLengthFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "units",
                |m: &FeatureCollectionPBuffer_GeometryProperties| { &m.units },
                |m: &mut FeatureCollectionPBuffer_GeometryProperties| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_GeometryProperties>(
                "FeatureCollectionPBuffer.GeometryProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_GeometryProperties {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_GeometryProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_GeometryProperties::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_GeometryProperties {
    fn clear(&mut self) {
        self.shapeAreaFieldName.clear();
        self.shapeLengthFieldName.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_GeometryProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_GeometryProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_ServerGens {
    // message fields
    pub minServerGen: u64,
    pub serverGen: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_ServerGens {
    fn default() -> &'a FeatureCollectionPBuffer_ServerGens {
        <FeatureCollectionPBuffer_ServerGens as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_ServerGens {
    pub fn new() -> FeatureCollectionPBuffer_ServerGens {
        ::std::default::Default::default()
    }

    // uint64 minServerGen = 1;


    pub fn get_minServerGen(&self) -> u64 {
        self.minServerGen
    }
    pub fn clear_minServerGen(&mut self) {
        self.minServerGen = 0;
    }

    // Param is passed by value, moved
    pub fn set_minServerGen(&mut self, v: u64) {
        self.minServerGen = v;
    }

    // uint64 serverGen = 2;


    pub fn get_serverGen(&self) -> u64 {
        self.serverGen
    }
    pub fn clear_serverGen(&mut self) {
        self.serverGen = 0;
    }

    // Param is passed by value, moved
    pub fn set_serverGen(&mut self, v: u64) {
        self.serverGen = v;
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_ServerGens {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minServerGen = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverGen = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.minServerGen != 0 {
            my_size += ::protobuf::rt::value_size(1, self.minServerGen, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.serverGen != 0 {
            my_size += ::protobuf::rt::value_size(2, self.serverGen, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.minServerGen != 0 {
            os.write_uint64(1, self.minServerGen)?;
        }
        if self.serverGen != 0 {
            os.write_uint64(2, self.serverGen)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_ServerGens {
        FeatureCollectionPBuffer_ServerGens::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minServerGen",
                |m: &FeatureCollectionPBuffer_ServerGens| { &m.minServerGen },
                |m: &mut FeatureCollectionPBuffer_ServerGens| { &mut m.minServerGen },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "serverGen",
                |m: &FeatureCollectionPBuffer_ServerGens| { &m.serverGen },
                |m: &mut FeatureCollectionPBuffer_ServerGens| { &mut m.serverGen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_ServerGens>(
                "FeatureCollectionPBuffer.ServerGens",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_ServerGens {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_ServerGens> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_ServerGens::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_ServerGens {
    fn clear(&mut self) {
        self.minServerGen = 0;
        self.serverGen = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_ServerGens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_ServerGens {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Scale {
    // message fields
    pub xScale: f64,
    pub yScale: f64,
    pub mScale: f64,
    pub zScale: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Scale {
    fn default() -> &'a FeatureCollectionPBuffer_Scale {
        <FeatureCollectionPBuffer_Scale as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_Scale {
    pub fn new() -> FeatureCollectionPBuffer_Scale {
        ::std::default::Default::default()
    }

    // double xScale = 1;


    pub fn get_xScale(&self) -> f64 {
        self.xScale
    }
    pub fn clear_xScale(&mut self) {
        self.xScale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_xScale(&mut self, v: f64) {
        self.xScale = v;
    }

    // double yScale = 2;


    pub fn get_yScale(&self) -> f64 {
        self.yScale
    }
    pub fn clear_yScale(&mut self) {
        self.yScale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yScale(&mut self, v: f64) {
        self.yScale = v;
    }

    // double mScale = 3;


    pub fn get_mScale(&self) -> f64 {
        self.mScale
    }
    pub fn clear_mScale(&mut self) {
        self.mScale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mScale(&mut self, v: f64) {
        self.mScale = v;
    }

    // double zScale = 4;


    pub fn get_zScale(&self) -> f64 {
        self.zScale
    }
    pub fn clear_zScale(&mut self) {
        self.zScale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_zScale(&mut self, v: f64) {
        self.zScale = v;
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Scale {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.xScale = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.yScale = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.mScale = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.zScale = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.xScale != 0. {
            my_size += 9;
        }
        if self.yScale != 0. {
            my_size += 9;
        }
        if self.mScale != 0. {
            my_size += 9;
        }
        if self.zScale != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.xScale != 0. {
            os.write_double(1, self.xScale)?;
        }
        if self.yScale != 0. {
            os.write_double(2, self.yScale)?;
        }
        if self.mScale != 0. {
            os.write_double(3, self.mScale)?;
        }
        if self.zScale != 0. {
            os.write_double(4, self.zScale)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Scale {
        FeatureCollectionPBuffer_Scale::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "xScale",
                |m: &FeatureCollectionPBuffer_Scale| { &m.xScale },
                |m: &mut FeatureCollectionPBuffer_Scale| { &mut m.xScale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "yScale",
                |m: &FeatureCollectionPBuffer_Scale| { &m.yScale },
                |m: &mut FeatureCollectionPBuffer_Scale| { &mut m.yScale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "mScale",
                |m: &FeatureCollectionPBuffer_Scale| { &m.mScale },
                |m: &mut FeatureCollectionPBuffer_Scale| { &mut m.mScale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "zScale",
                |m: &FeatureCollectionPBuffer_Scale| { &m.zScale },
                |m: &mut FeatureCollectionPBuffer_Scale| { &mut m.zScale },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Scale>(
                "FeatureCollectionPBuffer.Scale",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Scale {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Scale> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Scale::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Scale {
    fn clear(&mut self) {
        self.xScale = 0.;
        self.yScale = 0.;
        self.mScale = 0.;
        self.zScale = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Scale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Scale {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Translate {
    // message fields
    pub xTranslate: f64,
    pub yTranslate: f64,
    pub mTranslate: f64,
    pub zTranslate: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Translate {
    fn default() -> &'a FeatureCollectionPBuffer_Translate {
        <FeatureCollectionPBuffer_Translate as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_Translate {
    pub fn new() -> FeatureCollectionPBuffer_Translate {
        ::std::default::Default::default()
    }

    // double xTranslate = 1;


    pub fn get_xTranslate(&self) -> f64 {
        self.xTranslate
    }
    pub fn clear_xTranslate(&mut self) {
        self.xTranslate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_xTranslate(&mut self, v: f64) {
        self.xTranslate = v;
    }

    // double yTranslate = 2;


    pub fn get_yTranslate(&self) -> f64 {
        self.yTranslate
    }
    pub fn clear_yTranslate(&mut self) {
        self.yTranslate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yTranslate(&mut self, v: f64) {
        self.yTranslate = v;
    }

    // double mTranslate = 3;


    pub fn get_mTranslate(&self) -> f64 {
        self.mTranslate
    }
    pub fn clear_mTranslate(&mut self) {
        self.mTranslate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mTranslate(&mut self, v: f64) {
        self.mTranslate = v;
    }

    // double zTranslate = 4;


    pub fn get_zTranslate(&self) -> f64 {
        self.zTranslate
    }
    pub fn clear_zTranslate(&mut self) {
        self.zTranslate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_zTranslate(&mut self, v: f64) {
        self.zTranslate = v;
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Translate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.xTranslate = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.yTranslate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.mTranslate = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.zTranslate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.xTranslate != 0. {
            my_size += 9;
        }
        if self.yTranslate != 0. {
            my_size += 9;
        }
        if self.mTranslate != 0. {
            my_size += 9;
        }
        if self.zTranslate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.xTranslate != 0. {
            os.write_double(1, self.xTranslate)?;
        }
        if self.yTranslate != 0. {
            os.write_double(2, self.yTranslate)?;
        }
        if self.mTranslate != 0. {
            os.write_double(3, self.mTranslate)?;
        }
        if self.zTranslate != 0. {
            os.write_double(4, self.zTranslate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Translate {
        FeatureCollectionPBuffer_Translate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "xTranslate",
                |m: &FeatureCollectionPBuffer_Translate| { &m.xTranslate },
                |m: &mut FeatureCollectionPBuffer_Translate| { &mut m.xTranslate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "yTranslate",
                |m: &FeatureCollectionPBuffer_Translate| { &m.yTranslate },
                |m: &mut FeatureCollectionPBuffer_Translate| { &mut m.yTranslate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "mTranslate",
                |m: &FeatureCollectionPBuffer_Translate| { &m.mTranslate },
                |m: &mut FeatureCollectionPBuffer_Translate| { &mut m.mTranslate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "zTranslate",
                |m: &FeatureCollectionPBuffer_Translate| { &m.zTranslate },
                |m: &mut FeatureCollectionPBuffer_Translate| { &mut m.zTranslate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Translate>(
                "FeatureCollectionPBuffer.Translate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Translate {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Translate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Translate::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Translate {
    fn clear(&mut self) {
        self.xTranslate = 0.;
        self.yTranslate = 0.;
        self.mTranslate = 0.;
        self.zTranslate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Translate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Translate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_Transform {
    // message fields
    pub quantizeOriginPostion: FeatureCollectionPBuffer_QuantizeOriginPostion,
    pub scale: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_Scale>,
    pub translate: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_Translate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_Transform {
    fn default() -> &'a FeatureCollectionPBuffer_Transform {
        <FeatureCollectionPBuffer_Transform as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_Transform {
    pub fn new() -> FeatureCollectionPBuffer_Transform {
        ::std::default::Default::default()
    }

    // .esriPBuffer.FeatureCollectionPBuffer.QuantizeOriginPostion quantizeOriginPostion = 1;


    pub fn get_quantizeOriginPostion(&self) -> FeatureCollectionPBuffer_QuantizeOriginPostion {
        self.quantizeOriginPostion
    }
    pub fn clear_quantizeOriginPostion(&mut self) {
        self.quantizeOriginPostion = FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft;
    }

    // Param is passed by value, moved
    pub fn set_quantizeOriginPostion(&mut self, v: FeatureCollectionPBuffer_QuantizeOriginPostion) {
        self.quantizeOriginPostion = v;
    }

    // .esriPBuffer.FeatureCollectionPBuffer.Scale scale = 2;


    pub fn get_scale(&self) -> &FeatureCollectionPBuffer_Scale {
        self.scale.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_Scale as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scale(&mut self) {
        self.scale.clear();
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: FeatureCollectionPBuffer_Scale) {
        self.scale = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale(&mut self) -> &mut FeatureCollectionPBuffer_Scale {
        if self.scale.is_none() {
            self.scale.set_default();
        }
        self.scale.as_mut().unwrap()
    }

    // Take field
    pub fn take_scale(&mut self) -> FeatureCollectionPBuffer_Scale {
        self.scale.take().unwrap_or_else(|| FeatureCollectionPBuffer_Scale::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.Translate translate = 3;


    pub fn get_translate(&self) -> &FeatureCollectionPBuffer_Translate {
        self.translate.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_Translate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_translate(&mut self) {
        self.translate.clear();
    }

    pub fn has_translate(&self) -> bool {
        self.translate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translate(&mut self, v: FeatureCollectionPBuffer_Translate) {
        self.translate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translate(&mut self) -> &mut FeatureCollectionPBuffer_Translate {
        if self.translate.is_none() {
            self.translate.set_default();
        }
        self.translate.as_mut().unwrap()
    }

    // Take field
    pub fn take_translate(&mut self) -> FeatureCollectionPBuffer_Translate {
        self.translate.take().unwrap_or_else(|| FeatureCollectionPBuffer_Translate::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_Transform {
    fn is_initialized(&self) -> bool {
        for v in &self.scale {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.quantizeOriginPostion, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scale)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.quantizeOriginPostion != FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft {
            my_size += ::protobuf::rt::enum_size(1, self.quantizeOriginPostion);
        }
        if let Some(ref v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.translate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.quantizeOriginPostion != FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.quantizeOriginPostion))?;
        }
        if let Some(ref v) = self.scale.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.translate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_Transform {
        FeatureCollectionPBuffer_Transform::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureCollectionPBuffer_QuantizeOriginPostion>>(
                "quantizeOriginPostion",
                |m: &FeatureCollectionPBuffer_Transform| { &m.quantizeOriginPostion },
                |m: &mut FeatureCollectionPBuffer_Transform| { &mut m.quantizeOriginPostion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Scale>>(
                "scale",
                |m: &FeatureCollectionPBuffer_Transform| { &m.scale },
                |m: &mut FeatureCollectionPBuffer_Transform| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Translate>>(
                "translate",
                |m: &FeatureCollectionPBuffer_Transform| { &m.translate },
                |m: &mut FeatureCollectionPBuffer_Transform| { &mut m.translate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_Transform>(
                "FeatureCollectionPBuffer.Transform",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_Transform {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_Transform> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_Transform::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_Transform {
    fn clear(&mut self) {
        self.quantizeOriginPostion = FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft;
        self.scale.clear();
        self.translate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_Transform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_Transform {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_FeatureResult {
    // message fields
    pub objectIdFieldName: ::std::string::String,
    pub uniqueIdField: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_UniqueIdField>,
    pub globalIdFieldName: ::std::string::String,
    pub geohashFieldName: ::std::string::String,
    pub geometryProperties: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_GeometryProperties>,
    pub serverGens: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_ServerGens>,
    pub geometryType: FeatureCollectionPBuffer_GeometryType,
    pub spatialReference: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_SpatialReference>,
    pub exceededTransferLimit: bool,
    pub hasZ: bool,
    pub hasM: bool,
    pub transform: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_Transform>,
    pub fields: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Field>,
    pub values: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value>,
    pub features: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Feature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_FeatureResult {
    fn default() -> &'a FeatureCollectionPBuffer_FeatureResult {
        <FeatureCollectionPBuffer_FeatureResult as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_FeatureResult {
    pub fn new() -> FeatureCollectionPBuffer_FeatureResult {
        ::std::default::Default::default()
    }

    // string objectIdFieldName = 1;


    pub fn get_objectIdFieldName(&self) -> &str {
        &self.objectIdFieldName
    }
    pub fn clear_objectIdFieldName(&mut self) {
        self.objectIdFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectIdFieldName(&mut self, v: ::std::string::String) {
        self.objectIdFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectIdFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.objectIdFieldName
    }

    // Take field
    pub fn take_objectIdFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.objectIdFieldName, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.UniqueIdField uniqueIdField = 2;


    pub fn get_uniqueIdField(&self) -> &FeatureCollectionPBuffer_UniqueIdField {
        self.uniqueIdField.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_UniqueIdField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uniqueIdField(&mut self) {
        self.uniqueIdField.clear();
    }

    pub fn has_uniqueIdField(&self) -> bool {
        self.uniqueIdField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueIdField(&mut self, v: FeatureCollectionPBuffer_UniqueIdField) {
        self.uniqueIdField = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uniqueIdField(&mut self) -> &mut FeatureCollectionPBuffer_UniqueIdField {
        if self.uniqueIdField.is_none() {
            self.uniqueIdField.set_default();
        }
        self.uniqueIdField.as_mut().unwrap()
    }

    // Take field
    pub fn take_uniqueIdField(&mut self) -> FeatureCollectionPBuffer_UniqueIdField {
        self.uniqueIdField.take().unwrap_or_else(|| FeatureCollectionPBuffer_UniqueIdField::new())
    }

    // string globalIdFieldName = 3;


    pub fn get_globalIdFieldName(&self) -> &str {
        &self.globalIdFieldName
    }
    pub fn clear_globalIdFieldName(&mut self) {
        self.globalIdFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_globalIdFieldName(&mut self, v: ::std::string::String) {
        self.globalIdFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_globalIdFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.globalIdFieldName
    }

    // Take field
    pub fn take_globalIdFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.globalIdFieldName, ::std::string::String::new())
    }

    // string geohashFieldName = 4;


    pub fn get_geohashFieldName(&self) -> &str {
        &self.geohashFieldName
    }
    pub fn clear_geohashFieldName(&mut self) {
        self.geohashFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_geohashFieldName(&mut self, v: ::std::string::String) {
        self.geohashFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geohashFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.geohashFieldName
    }

    // Take field
    pub fn take_geohashFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.geohashFieldName, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.GeometryProperties geometryProperties = 5;


    pub fn get_geometryProperties(&self) -> &FeatureCollectionPBuffer_GeometryProperties {
        self.geometryProperties.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_GeometryProperties as ::protobuf::Message>::default_instance())
    }
    pub fn clear_geometryProperties(&mut self) {
        self.geometryProperties.clear();
    }

    pub fn has_geometryProperties(&self) -> bool {
        self.geometryProperties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometryProperties(&mut self, v: FeatureCollectionPBuffer_GeometryProperties) {
        self.geometryProperties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometryProperties(&mut self) -> &mut FeatureCollectionPBuffer_GeometryProperties {
        if self.geometryProperties.is_none() {
            self.geometryProperties.set_default();
        }
        self.geometryProperties.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometryProperties(&mut self) -> FeatureCollectionPBuffer_GeometryProperties {
        self.geometryProperties.take().unwrap_or_else(|| FeatureCollectionPBuffer_GeometryProperties::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.ServerGens serverGens = 6;


    pub fn get_serverGens(&self) -> &FeatureCollectionPBuffer_ServerGens {
        self.serverGens.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_ServerGens as ::protobuf::Message>::default_instance())
    }
    pub fn clear_serverGens(&mut self) {
        self.serverGens.clear();
    }

    pub fn has_serverGens(&self) -> bool {
        self.serverGens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverGens(&mut self, v: FeatureCollectionPBuffer_ServerGens) {
        self.serverGens = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverGens(&mut self) -> &mut FeatureCollectionPBuffer_ServerGens {
        if self.serverGens.is_none() {
            self.serverGens.set_default();
        }
        self.serverGens.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverGens(&mut self) -> FeatureCollectionPBuffer_ServerGens {
        self.serverGens.take().unwrap_or_else(|| FeatureCollectionPBuffer_ServerGens::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.GeometryType geometryType = 7;


    pub fn get_geometryType(&self) -> FeatureCollectionPBuffer_GeometryType {
        self.geometryType
    }
    pub fn clear_geometryType(&mut self) {
        self.geometryType = FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint;
    }

    // Param is passed by value, moved
    pub fn set_geometryType(&mut self, v: FeatureCollectionPBuffer_GeometryType) {
        self.geometryType = v;
    }

    // .esriPBuffer.FeatureCollectionPBuffer.SpatialReference spatialReference = 8;


    pub fn get_spatialReference(&self) -> &FeatureCollectionPBuffer_SpatialReference {
        self.spatialReference.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_SpatialReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spatialReference(&mut self) {
        self.spatialReference.clear();
    }

    pub fn has_spatialReference(&self) -> bool {
        self.spatialReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spatialReference(&mut self, v: FeatureCollectionPBuffer_SpatialReference) {
        self.spatialReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spatialReference(&mut self) -> &mut FeatureCollectionPBuffer_SpatialReference {
        if self.spatialReference.is_none() {
            self.spatialReference.set_default();
        }
        self.spatialReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_spatialReference(&mut self) -> FeatureCollectionPBuffer_SpatialReference {
        self.spatialReference.take().unwrap_or_else(|| FeatureCollectionPBuffer_SpatialReference::new())
    }

    // bool exceededTransferLimit = 9;


    pub fn get_exceededTransferLimit(&self) -> bool {
        self.exceededTransferLimit
    }
    pub fn clear_exceededTransferLimit(&mut self) {
        self.exceededTransferLimit = false;
    }

    // Param is passed by value, moved
    pub fn set_exceededTransferLimit(&mut self, v: bool) {
        self.exceededTransferLimit = v;
    }

    // bool hasZ = 10;


    pub fn get_hasZ(&self) -> bool {
        self.hasZ
    }
    pub fn clear_hasZ(&mut self) {
        self.hasZ = false;
    }

    // Param is passed by value, moved
    pub fn set_hasZ(&mut self, v: bool) {
        self.hasZ = v;
    }

    // bool hasM = 11;


    pub fn get_hasM(&self) -> bool {
        self.hasM
    }
    pub fn clear_hasM(&mut self) {
        self.hasM = false;
    }

    // Param is passed by value, moved
    pub fn set_hasM(&mut self, v: bool) {
        self.hasM = v;
    }

    // .esriPBuffer.FeatureCollectionPBuffer.Transform transform = 12;


    pub fn get_transform(&self) -> &FeatureCollectionPBuffer_Transform {
        self.transform.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_Transform as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transform(&mut self) {
        self.transform.clear();
    }

    pub fn has_transform(&self) -> bool {
        self.transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform(&mut self, v: FeatureCollectionPBuffer_Transform) {
        self.transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transform(&mut self) -> &mut FeatureCollectionPBuffer_Transform {
        if self.transform.is_none() {
            self.transform.set_default();
        }
        self.transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_transform(&mut self) -> FeatureCollectionPBuffer_Transform {
        self.transform.take().unwrap_or_else(|| FeatureCollectionPBuffer_Transform::new())
    }

    // repeated .esriPBuffer.FeatureCollectionPBuffer.Field fields = 13;


    pub fn get_fields(&self) -> &[FeatureCollectionPBuffer_Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<FeatureCollectionPBuffer_Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<FeatureCollectionPBuffer_Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    // repeated .esriPBuffer.FeatureCollectionPBuffer.Value values = 14;


    pub fn get_values(&self) -> &[FeatureCollectionPBuffer_Value] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<FeatureCollectionPBuffer_Value> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    // repeated .esriPBuffer.FeatureCollectionPBuffer.Feature features = 15;


    pub fn get_features(&self) -> &[FeatureCollectionPBuffer_Feature] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<FeatureCollectionPBuffer_Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<FeatureCollectionPBuffer_Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<FeatureCollectionPBuffer_Feature> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_FeatureResult {
    fn is_initialized(&self) -> bool {
        for v in &self.uniqueIdField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geometryProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverGens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spatialReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.objectIdFieldName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uniqueIdField)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.globalIdFieldName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.geohashFieldName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometryProperties)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverGens)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.geometryType, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spatialReference)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exceededTransferLimit = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasZ = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasM = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transform)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.objectIdFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.objectIdFieldName);
        }
        if let Some(ref v) = self.uniqueIdField.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.globalIdFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.globalIdFieldName);
        }
        if !self.geohashFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.geohashFieldName);
        }
        if let Some(ref v) = self.geometryProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverGens.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.geometryType != FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint {
            my_size += ::protobuf::rt::enum_size(7, self.geometryType);
        }
        if let Some(ref v) = self.spatialReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.exceededTransferLimit != false {
            my_size += 2;
        }
        if self.hasZ != false {
            my_size += 2;
        }
        if self.hasM != false {
            my_size += 2;
        }
        if let Some(ref v) = self.transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.objectIdFieldName.is_empty() {
            os.write_string(1, &self.objectIdFieldName)?;
        }
        if let Some(ref v) = self.uniqueIdField.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.globalIdFieldName.is_empty() {
            os.write_string(3, &self.globalIdFieldName)?;
        }
        if !self.geohashFieldName.is_empty() {
            os.write_string(4, &self.geohashFieldName)?;
        }
        if let Some(ref v) = self.geometryProperties.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverGens.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.geometryType != FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.geometryType))?;
        }
        if let Some(ref v) = self.spatialReference.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.exceededTransferLimit != false {
            os.write_bool(9, self.exceededTransferLimit)?;
        }
        if self.hasZ != false {
            os.write_bool(10, self.hasZ)?;
        }
        if self.hasM != false {
            os.write_bool(11, self.hasM)?;
        }
        if let Some(ref v) = self.transform.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.fields {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.values {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.features {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_FeatureResult {
        FeatureCollectionPBuffer_FeatureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "objectIdFieldName",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.objectIdFieldName },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.objectIdFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_UniqueIdField>>(
                "uniqueIdField",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.uniqueIdField },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.uniqueIdField },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "globalIdFieldName",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.globalIdFieldName },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.globalIdFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "geohashFieldName",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.geohashFieldName },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.geohashFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_GeometryProperties>>(
                "geometryProperties",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.geometryProperties },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.geometryProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_ServerGens>>(
                "serverGens",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.serverGens },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.serverGens },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FeatureCollectionPBuffer_GeometryType>>(
                "geometryType",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.geometryType },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.geometryType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_SpatialReference>>(
                "spatialReference",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.spatialReference },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.spatialReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exceededTransferLimit",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.exceededTransferLimit },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.exceededTransferLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasZ",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.hasZ },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.hasZ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasM",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.hasM },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.hasM },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Transform>>(
                "transform",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.transform },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.transform },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Field>>(
                "fields",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.fields },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Value>>(
                "values",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.values },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.values },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_Feature>>(
                "features",
                |m: &FeatureCollectionPBuffer_FeatureResult| { &m.features },
                |m: &mut FeatureCollectionPBuffer_FeatureResult| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_FeatureResult>(
                "FeatureCollectionPBuffer.FeatureResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_FeatureResult {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_FeatureResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_FeatureResult::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_FeatureResult {
    fn clear(&mut self) {
        self.objectIdFieldName.clear();
        self.uniqueIdField.clear();
        self.globalIdFieldName.clear();
        self.geohashFieldName.clear();
        self.geometryProperties.clear();
        self.serverGens.clear();
        self.geometryType = FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint;
        self.spatialReference.clear();
        self.exceededTransferLimit = false;
        self.hasZ = false;
        self.hasM = false;
        self.transform.clear();
        self.fields.clear();
        self.values.clear();
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_FeatureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_FeatureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_CountResult {
    // message fields
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_CountResult {
    fn default() -> &'a FeatureCollectionPBuffer_CountResult {
        <FeatureCollectionPBuffer_CountResult as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_CountResult {
    pub fn new() -> FeatureCollectionPBuffer_CountResult {
        ::std::default::Default::default()
    }

    // uint64 count = 1;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_CountResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_CountResult {
        FeatureCollectionPBuffer_CountResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &FeatureCollectionPBuffer_CountResult| { &m.count },
                |m: &mut FeatureCollectionPBuffer_CountResult| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_CountResult>(
                "FeatureCollectionPBuffer.CountResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_CountResult {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_CountResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_CountResult::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_CountResult {
    fn clear(&mut self) {
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_CountResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_CountResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_ObjectIdsResult {
    // message fields
    pub objectIdFieldName: ::std::string::String,
    pub serverGens: ::protobuf::SingularPtrField<FeatureCollectionPBuffer_ServerGens>,
    pub objectIds: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_ObjectIdsResult {
    fn default() -> &'a FeatureCollectionPBuffer_ObjectIdsResult {
        <FeatureCollectionPBuffer_ObjectIdsResult as ::protobuf::Message>::default_instance()
    }
}

impl FeatureCollectionPBuffer_ObjectIdsResult {
    pub fn new() -> FeatureCollectionPBuffer_ObjectIdsResult {
        ::std::default::Default::default()
    }

    // string objectIdFieldName = 1;


    pub fn get_objectIdFieldName(&self) -> &str {
        &self.objectIdFieldName
    }
    pub fn clear_objectIdFieldName(&mut self) {
        self.objectIdFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectIdFieldName(&mut self, v: ::std::string::String) {
        self.objectIdFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectIdFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.objectIdFieldName
    }

    // Take field
    pub fn take_objectIdFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.objectIdFieldName, ::std::string::String::new())
    }

    // .esriPBuffer.FeatureCollectionPBuffer.ServerGens serverGens = 2;


    pub fn get_serverGens(&self) -> &FeatureCollectionPBuffer_ServerGens {
        self.serverGens.as_ref().unwrap_or_else(|| <FeatureCollectionPBuffer_ServerGens as ::protobuf::Message>::default_instance())
    }
    pub fn clear_serverGens(&mut self) {
        self.serverGens.clear();
    }

    pub fn has_serverGens(&self) -> bool {
        self.serverGens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverGens(&mut self, v: FeatureCollectionPBuffer_ServerGens) {
        self.serverGens = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverGens(&mut self) -> &mut FeatureCollectionPBuffer_ServerGens {
        if self.serverGens.is_none() {
            self.serverGens.set_default();
        }
        self.serverGens.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverGens(&mut self) -> FeatureCollectionPBuffer_ServerGens {
        self.serverGens.take().unwrap_or_else(|| FeatureCollectionPBuffer_ServerGens::new())
    }

    // repeated uint64 objectIds = 3;


    pub fn get_objectIds(&self) -> &[u64] {
        &self.objectIds
    }
    pub fn clear_objectIds(&mut self) {
        self.objectIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectIds(&mut self, v: ::std::vec::Vec<u64>) {
        self.objectIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objectIds(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.objectIds
    }

    // Take field
    pub fn take_objectIds(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.objectIds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_ObjectIdsResult {
    fn is_initialized(&self) -> bool {
        for v in &self.serverGens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.objectIdFieldName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverGens)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.objectIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.objectIdFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.objectIdFieldName);
        }
        if let Some(ref v) = self.serverGens.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.objectIds.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.objectIds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.objectIdFieldName.is_empty() {
            os.write_string(1, &self.objectIdFieldName)?;
        }
        if let Some(ref v) = self.serverGens.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.objectIds.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.objectIds))?;
            for v in &self.objectIds {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_ObjectIdsResult {
        FeatureCollectionPBuffer_ObjectIdsResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "objectIdFieldName",
                |m: &FeatureCollectionPBuffer_ObjectIdsResult| { &m.objectIdFieldName },
                |m: &mut FeatureCollectionPBuffer_ObjectIdsResult| { &mut m.objectIdFieldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureCollectionPBuffer_ServerGens>>(
                "serverGens",
                |m: &FeatureCollectionPBuffer_ObjectIdsResult| { &m.serverGens },
                |m: &mut FeatureCollectionPBuffer_ObjectIdsResult| { &mut m.serverGens },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "objectIds",
                |m: &FeatureCollectionPBuffer_ObjectIdsResult| { &m.objectIds },
                |m: &mut FeatureCollectionPBuffer_ObjectIdsResult| { &mut m.objectIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_ObjectIdsResult>(
                "FeatureCollectionPBuffer.ObjectIdsResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_ObjectIdsResult {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_ObjectIdsResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_ObjectIdsResult::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_ObjectIdsResult {
    fn clear(&mut self) {
        self.objectIdFieldName.clear();
        self.serverGens.clear();
        self.objectIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_ObjectIdsResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_ObjectIdsResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureCollectionPBuffer_QueryResult {
    // message oneof groups
    pub Results: ::std::option::Option<FeatureCollectionPBuffer_QueryResult_oneof_Results>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureCollectionPBuffer_QueryResult {
    fn default() -> &'a FeatureCollectionPBuffer_QueryResult {
        <FeatureCollectionPBuffer_QueryResult as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeatureCollectionPBuffer_QueryResult_oneof_Results {
    featureResult(FeatureCollectionPBuffer_FeatureResult),
    countResult(FeatureCollectionPBuffer_CountResult),
    idsResult(FeatureCollectionPBuffer_ObjectIdsResult),
}

impl FeatureCollectionPBuffer_QueryResult {
    pub fn new() -> FeatureCollectionPBuffer_QueryResult {
        ::std::default::Default::default()
    }

    // .esriPBuffer.FeatureCollectionPBuffer.FeatureResult featureResult = 1;


    pub fn get_featureResult(&self) -> &FeatureCollectionPBuffer_FeatureResult {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(ref v)) => v,
            _ => <FeatureCollectionPBuffer_FeatureResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_featureResult(&mut self) {
        self.Results = ::std::option::Option::None;
    }

    pub fn has_featureResult(&self) -> bool {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_featureResult(&mut self, v: FeatureCollectionPBuffer_FeatureResult) {
        self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(v))
    }

    // Mutable pointer to the field.
    pub fn mut_featureResult(&mut self) -> &mut FeatureCollectionPBuffer_FeatureResult {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(_)) = self.Results {
        } else {
            self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(FeatureCollectionPBuffer_FeatureResult::new()));
        }
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_featureResult(&mut self) -> FeatureCollectionPBuffer_FeatureResult {
        if self.has_featureResult() {
            match self.Results.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureCollectionPBuffer_FeatureResult::new()
        }
    }

    // .esriPBuffer.FeatureCollectionPBuffer.CountResult countResult = 2;


    pub fn get_countResult(&self) -> &FeatureCollectionPBuffer_CountResult {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(ref v)) => v,
            _ => <FeatureCollectionPBuffer_CountResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_countResult(&mut self) {
        self.Results = ::std::option::Option::None;
    }

    pub fn has_countResult(&self) -> bool {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_countResult(&mut self, v: FeatureCollectionPBuffer_CountResult) {
        self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(v))
    }

    // Mutable pointer to the field.
    pub fn mut_countResult(&mut self) -> &mut FeatureCollectionPBuffer_CountResult {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(_)) = self.Results {
        } else {
            self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(FeatureCollectionPBuffer_CountResult::new()));
        }
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_countResult(&mut self) -> FeatureCollectionPBuffer_CountResult {
        if self.has_countResult() {
            match self.Results.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureCollectionPBuffer_CountResult::new()
        }
    }

    // .esriPBuffer.FeatureCollectionPBuffer.ObjectIdsResult idsResult = 3;


    pub fn get_idsResult(&self) -> &FeatureCollectionPBuffer_ObjectIdsResult {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(ref v)) => v,
            _ => <FeatureCollectionPBuffer_ObjectIdsResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_idsResult(&mut self) {
        self.Results = ::std::option::Option::None;
    }

    pub fn has_idsResult(&self) -> bool {
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_idsResult(&mut self, v: FeatureCollectionPBuffer_ObjectIdsResult) {
        self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(v))
    }

    // Mutable pointer to the field.
    pub fn mut_idsResult(&mut self) -> &mut FeatureCollectionPBuffer_ObjectIdsResult {
        if let ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(_)) = self.Results {
        } else {
            self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(FeatureCollectionPBuffer_ObjectIdsResult::new()));
        }
        match self.Results {
            ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_idsResult(&mut self) -> FeatureCollectionPBuffer_ObjectIdsResult {
        if self.has_idsResult() {
            match self.Results.take() {
                ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureCollectionPBuffer_ObjectIdsResult::new()
        }
    }
}

impl ::protobuf::Message for FeatureCollectionPBuffer_QueryResult {
    fn is_initialized(&self) -> bool {
        if let Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(ref v)) = self.Results {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(ref v)) = self.Results {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(ref v)) = self.Results {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Results = ::std::option::Option::Some(FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Results {
            match v {
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Results {
            match v {
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::featureResult(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::countResult(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FeatureCollectionPBuffer_QueryResult_oneof_Results::idsResult(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureCollectionPBuffer_QueryResult {
        FeatureCollectionPBuffer_QueryResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FeatureCollectionPBuffer_FeatureResult>(
                "featureResult",
                FeatureCollectionPBuffer_QueryResult::has_featureResult,
                FeatureCollectionPBuffer_QueryResult::get_featureResult,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FeatureCollectionPBuffer_CountResult>(
                "countResult",
                FeatureCollectionPBuffer_QueryResult::has_countResult,
                FeatureCollectionPBuffer_QueryResult::get_countResult,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FeatureCollectionPBuffer_ObjectIdsResult>(
                "idsResult",
                FeatureCollectionPBuffer_QueryResult::has_idsResult,
                FeatureCollectionPBuffer_QueryResult::get_idsResult,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureCollectionPBuffer_QueryResult>(
                "FeatureCollectionPBuffer.QueryResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureCollectionPBuffer_QueryResult {
        static instance: ::protobuf::rt::LazyV2<FeatureCollectionPBuffer_QueryResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureCollectionPBuffer_QueryResult::new)
    }
}

impl ::protobuf::Clear for FeatureCollectionPBuffer_QueryResult {
    fn clear(&mut self) {
        self.Results = ::std::option::Option::None;
        self.Results = ::std::option::Option::None;
        self.Results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureCollectionPBuffer_QueryResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_QueryResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FeatureCollectionPBuffer_GeometryType {
    esriGeometryTypePoint = 0,
    esriGeometryTypeMultipoint = 1,
    esriGeometryTypePolyline = 2,
    esriGeometryTypePolygon = 3,
    esriGeometryTypeMultipatch = 4,
    esriGeometryTypeNone = 127,
}

impl ::protobuf::ProtobufEnum for FeatureCollectionPBuffer_GeometryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeatureCollectionPBuffer_GeometryType> {
        match value {
            0 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint),
            1 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypeMultipoint),
            2 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypePolyline),
            3 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypePolygon),
            4 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypeMultipatch),
            127 => ::std::option::Option::Some(FeatureCollectionPBuffer_GeometryType::esriGeometryTypeNone),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FeatureCollectionPBuffer_GeometryType] = &[
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint,
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypeMultipoint,
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypePolyline,
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypePolygon,
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypeMultipatch,
            FeatureCollectionPBuffer_GeometryType::esriGeometryTypeNone,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FeatureCollectionPBuffer_GeometryType>("FeatureCollectionPBuffer.GeometryType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FeatureCollectionPBuffer_GeometryType {
}

impl ::std::default::Default for FeatureCollectionPBuffer_GeometryType {
    fn default() -> Self {
        FeatureCollectionPBuffer_GeometryType::esriGeometryTypePoint
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_GeometryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FeatureCollectionPBuffer_FieldType {
    esriFieldTypeSmallInteger = 0,
    esriFieldTypeInteger = 1,
    esriFieldTypeSingle = 2,
    esriFieldTypeDouble = 3,
    esriFieldTypeString = 4,
    esriFieldTypeDate = 5,
    esriFieldTypeOID = 6,
    esriFieldTypeGeometry = 7,
    esriFieldTypeBlob = 8,
    esriFieldTypeRaster = 9,
    esriFieldTypeGUID = 10,
    esriFieldTypeGlobalID = 11,
    esriFieldTypeXML = 12,
}

impl ::protobuf::ProtobufEnum for FeatureCollectionPBuffer_FieldType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeatureCollectionPBuffer_FieldType> {
        match value {
            0 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger),
            1 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeInteger),
            2 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeSingle),
            3 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeDouble),
            4 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeString),
            5 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeDate),
            6 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeOID),
            7 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeGeometry),
            8 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeBlob),
            9 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeRaster),
            10 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeGUID),
            11 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeGlobalID),
            12 => ::std::option::Option::Some(FeatureCollectionPBuffer_FieldType::esriFieldTypeXML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FeatureCollectionPBuffer_FieldType] = &[
            FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeInteger,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeSingle,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeDouble,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeString,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeDate,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeOID,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeGeometry,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeBlob,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeRaster,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeGUID,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeGlobalID,
            FeatureCollectionPBuffer_FieldType::esriFieldTypeXML,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FeatureCollectionPBuffer_FieldType>("FeatureCollectionPBuffer.FieldType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FeatureCollectionPBuffer_FieldType {
}

impl ::std::default::Default for FeatureCollectionPBuffer_FieldType {
    fn default() -> Self {
        FeatureCollectionPBuffer_FieldType::esriFieldTypeSmallInteger
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_FieldType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FeatureCollectionPBuffer_SQLType {
    sqlTypeBigInt = 0,
    sqlTypeBinary = 1,
    sqlTypeBit = 2,
    sqlTypeChar = 3,
    sqlTypeDate = 4,
    sqlTypeDecimal = 5,
    sqlTypeDouble = 6,
    sqlTypeFloat = 7,
    sqlTypeGeometry = 8,
    sqlTypeGUID = 9,
    sqlTypeInteger = 10,
    sqlTypeLongNVarchar = 11,
    sqlTypeLongVarbinary = 12,
    sqlTypeLongVarchar = 13,
    sqlTypeNChar = 14,
    sqlTypeNVarchar = 15,
    sqlTypeOther = 16,
    sqlTypeReal = 17,
    sqlTypeSmallInt = 18,
    sqlTypeSqlXml = 19,
    sqlTypeTime = 20,
    sqlTypeTimestamp = 21,
    sqlTypeTimestamp2 = 22,
    sqlTypeTinyInt = 23,
    sqlTypeVarbinary = 24,
    sqlTypeVarchar = 25,
}

impl ::protobuf::ProtobufEnum for FeatureCollectionPBuffer_SQLType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeatureCollectionPBuffer_SQLType> {
        match value {
            0 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeBigInt),
            1 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeBinary),
            2 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeBit),
            3 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeChar),
            4 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeDate),
            5 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeDecimal),
            6 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeDouble),
            7 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeFloat),
            8 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeGeometry),
            9 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeGUID),
            10 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeInteger),
            11 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeLongNVarchar),
            12 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeLongVarbinary),
            13 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeLongVarchar),
            14 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeNChar),
            15 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeNVarchar),
            16 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeOther),
            17 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeReal),
            18 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeSmallInt),
            19 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeSqlXml),
            20 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeTime),
            21 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeTimestamp),
            22 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeTimestamp2),
            23 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeTinyInt),
            24 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeVarbinary),
            25 => ::std::option::Option::Some(FeatureCollectionPBuffer_SQLType::sqlTypeVarchar),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FeatureCollectionPBuffer_SQLType] = &[
            FeatureCollectionPBuffer_SQLType::sqlTypeBigInt,
            FeatureCollectionPBuffer_SQLType::sqlTypeBinary,
            FeatureCollectionPBuffer_SQLType::sqlTypeBit,
            FeatureCollectionPBuffer_SQLType::sqlTypeChar,
            FeatureCollectionPBuffer_SQLType::sqlTypeDate,
            FeatureCollectionPBuffer_SQLType::sqlTypeDecimal,
            FeatureCollectionPBuffer_SQLType::sqlTypeDouble,
            FeatureCollectionPBuffer_SQLType::sqlTypeFloat,
            FeatureCollectionPBuffer_SQLType::sqlTypeGeometry,
            FeatureCollectionPBuffer_SQLType::sqlTypeGUID,
            FeatureCollectionPBuffer_SQLType::sqlTypeInteger,
            FeatureCollectionPBuffer_SQLType::sqlTypeLongNVarchar,
            FeatureCollectionPBuffer_SQLType::sqlTypeLongVarbinary,
            FeatureCollectionPBuffer_SQLType::sqlTypeLongVarchar,
            FeatureCollectionPBuffer_SQLType::sqlTypeNChar,
            FeatureCollectionPBuffer_SQLType::sqlTypeNVarchar,
            FeatureCollectionPBuffer_SQLType::sqlTypeOther,
            FeatureCollectionPBuffer_SQLType::sqlTypeReal,
            FeatureCollectionPBuffer_SQLType::sqlTypeSmallInt,
            FeatureCollectionPBuffer_SQLType::sqlTypeSqlXml,
            FeatureCollectionPBuffer_SQLType::sqlTypeTime,
            FeatureCollectionPBuffer_SQLType::sqlTypeTimestamp,
            FeatureCollectionPBuffer_SQLType::sqlTypeTimestamp2,
            FeatureCollectionPBuffer_SQLType::sqlTypeTinyInt,
            FeatureCollectionPBuffer_SQLType::sqlTypeVarbinary,
            FeatureCollectionPBuffer_SQLType::sqlTypeVarchar,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FeatureCollectionPBuffer_SQLType>("FeatureCollectionPBuffer.SQLType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FeatureCollectionPBuffer_SQLType {
}

impl ::std::default::Default for FeatureCollectionPBuffer_SQLType {
    fn default() -> Self {
        FeatureCollectionPBuffer_SQLType::sqlTypeBigInt
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_SQLType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FeatureCollectionPBuffer_QuantizeOriginPostion {
    upperLeft = 0,
    lowerLeft = 1,
}

impl ::protobuf::ProtobufEnum for FeatureCollectionPBuffer_QuantizeOriginPostion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeatureCollectionPBuffer_QuantizeOriginPostion> {
        match value {
            0 => ::std::option::Option::Some(FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft),
            1 => ::std::option::Option::Some(FeatureCollectionPBuffer_QuantizeOriginPostion::lowerLeft),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FeatureCollectionPBuffer_QuantizeOriginPostion] = &[
            FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft,
            FeatureCollectionPBuffer_QuantizeOriginPostion::lowerLeft,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FeatureCollectionPBuffer_QuantizeOriginPostion>("FeatureCollectionPBuffer.QuantizeOriginPostion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FeatureCollectionPBuffer_QuantizeOriginPostion {
}

impl ::std::default::Default for FeatureCollectionPBuffer_QuantizeOriginPostion {
    fn default() -> Self {
        FeatureCollectionPBuffer_QuantizeOriginPostion::upperLeft
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureCollectionPBuffer_QuantizeOriginPostion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17FeatureCollection.proto\x12\x0besriPBuffer\"\x8f'\n\x18FeatureColl\
    ectionPBuffer\x12\x1a\n\x07version\x18\x01\x20\x01(\tR\x07versionB\0\x12\
    U\n\x0bqueryResult\x18\x02\x20\x01(\x0b21.esriPBuffer.FeatureCollectionP\
    Buffer.QueryResultR\x0bqueryResultB\0\x1a\xa6\x01\n\x10SpatialReference\
    \x12\x14\n\x04wkid\x18\x01\x20\x01(\rR\x04wkidB\0\x12\"\n\x0blastestWkid\
    \x18\x02\x20\x01(\rR\x0blastestWkidB\0\x12\x1a\n\x07vcsWkid\x18\x03\x20\
    \x01(\rR\x07vcsWkidB\0\x12&\n\rlatestVcsWkid\x18\x04\x20\x01(\rR\rlatest\
    VcsWkidB\0\x12\x12\n\x03wkt\x18\x05\x20\x01(\tR\x03wktB\0:\0\x1a\x93\x02\
    \n\x05Field\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12O\n\tfie\
    ldType\x18\x02\x20\x01(\x0e2/.esriPBuffer.FeatureCollectionPBuffer.Field\
    TypeR\tfieldTypeB\0\x12\x16\n\x05alias\x18\x03\x20\x01(\tR\x05aliasB\0\
    \x12I\n\x07sqlType\x18\x04\x20\x01(\x0e2-.esriPBuffer.FeatureCollectionP\
    Buffer.SQLTypeR\x07sqlTypeB\0\x12\x18\n\x06domain\x18\x05\x20\x01(\tR\
    \x06domainB\0\x12$\n\x0cdefaultValue\x18\x06\x20\x01(\tR\x0cdefaultValue\
    B\0:\0\x1a\xe6\x02\n\x05Value\x12%\n\x0cstring_value\x18\x01\x20\x01(\tH\
    \0R\x0bstringValueB\0\x12#\n\x0bfloat_value\x18\x02\x20\x01(\x02H\0R\nfl\
    oatValueB\0\x12%\n\x0cdouble_value\x18\x03\x20\x01(\x01H\0R\x0bdoubleVal\
    ueB\0\x12!\n\nsint_value\x18\x04\x20\x01(\x11H\0R\tsintValueB\0\x12!\n\n\
    uint_value\x18\x05\x20\x01(\rH\0R\tuintValueB\0\x12#\n\x0bint64_value\
    \x18\x06\x20\x01(\x03H\0R\nint64ValueB\0\x12%\n\x0cuint64_value\x18\x07\
    \x20\x01(\x04H\0R\x0buint64ValueB\0\x12%\n\x0csint64_value\x18\x08\x20\
    \x01(\x12H\0R\x0bsint64ValueB\0\x12!\n\nbool_value\x18\t\x20\x01(\x08H\0\
    R\tboolValueB\0B\x0c\n\nvalue_type:\0\x1aF\n\x08Geometry\x12\x1c\n\x07le\
    ngths\x18\x02\x20\x03(\rR\x07lengthsB\x02\x10\x01\x12\x1a\n\x06coords\
    \x18\x03\x20\x03(\x12R\x06coordsB\x02\x10\x01:\0\x1a+\n\x0fesriShapeBuff\
    er\x12\x16\n\x05bytes\x18\x01\x20\x01(\x0cR\x05bytesB\0:\0\x1a\xec\x02\n\
    \x07Feature\x12M\n\nattributes\x18\x01\x20\x03(\x0b2+.esriPBuffer.Featur\
    eCollectionPBuffer.ValueR\nattributesB\0\x12N\n\x08geometry\x18\x02\x20\
    \x01(\x0b2..esriPBuffer.FeatureCollectionPBuffer.GeometryH\0R\x08geometr\
    yB\0\x12[\n\x0bshapeBuffer\x18\x03\x20\x01(\x0b25.esriPBuffer.FeatureCol\
    lectionPBuffer.esriShapeBufferH\0R\x0bshapeBufferB\0\x12L\n\x08centroid\
    \x18\x04\x20\x01(\x0b2..esriPBuffer.FeatureCollectionPBuffer.GeometryR\
    \x08centroidB\0B\x15\n\x13compressed_geometry:\0\x1aY\n\rUniqueIdField\
    \x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x120\n\x12isSystemMain\
    tained\x18\x02\x20\x01(\x08R\x12isSystemMaintainedB\0:\0\x1a\x96\x01\n\
    \x12GeometryProperties\x120\n\x12shapeAreaFieldName\x18\x01\x20\x01(\tR\
    \x12shapeAreaFieldNameB\0\x124\n\x14shapeLengthFieldName\x18\x02\x20\x01\
    (\tR\x14shapeLengthFieldNameB\0\x12\x16\n\x05units\x18\x03\x20\x01(\tR\
    \x05unitsB\0:\0\x1aT\n\nServerGens\x12$\n\x0cminServerGen\x18\x01\x20\
    \x01(\x04R\x0cminServerGenB\0\x12\x1e\n\tserverGen\x18\x02\x20\x01(\x04R\
    \tserverGenB\0:\0\x1aq\n\x05Scale\x12\x18\n\x06xScale\x18\x01\x20\x01(\
    \x01R\x06xScaleB\0\x12\x18\n\x06yScale\x18\x02\x20\x01(\x01R\x06yScaleB\
    \0\x12\x18\n\x06mScale\x18\x03\x20\x01(\x01R\x06mScaleB\0\x12\x18\n\x06z\
    Scale\x18\x04\x20\x01(\x01R\x06zScaleB\0:\0\x1a\x95\x01\n\tTranslate\x12\
    \x20\n\nxTranslate\x18\x01\x20\x01(\x01R\nxTranslateB\0\x12\x20\n\nyTran\
    slate\x18\x02\x20\x01(\x01R\nyTranslateB\0\x12\x20\n\nmTranslate\x18\x03\
    \x20\x01(\x01R\nmTranslateB\0\x12\x20\n\nzTranslate\x18\x04\x20\x01(\x01\
    R\nzTranslateB\0:\0\x1a\x98\x02\n\tTransform\x12s\n\x15quantizeOriginPos\
    tion\x18\x01\x20\x01(\x0e2;.esriPBuffer.FeatureCollectionPBuffer.Quantiz\
    eOriginPostionR\x15quantizeOriginPostionB\0\x12C\n\x05scale\x18\x02\x20\
    \x01(\x0b2+.esriPBuffer.FeatureCollectionPBuffer.ScaleR\x05scaleB\0\x12O\
    \n\ttranslate\x18\x03\x20\x01(\x0b2/.esriPBuffer.FeatureCollectionPBuffe\
    r.TranslateR\ttranslateB\0:\0\x1a\x8c\x08\n\rFeatureResult\x12.\n\x11obj\
    ectIdFieldName\x18\x01\x20\x01(\tR\x11objectIdFieldNameB\0\x12[\n\runiqu\
    eIdField\x18\x02\x20\x01(\x0b23.esriPBuffer.FeatureCollectionPBuffer.Uni\
    queIdFieldR\runiqueIdFieldB\0\x12.\n\x11globalIdFieldName\x18\x03\x20\
    \x01(\tR\x11globalIdFieldNameB\0\x12,\n\x10geohashFieldName\x18\x04\x20\
    \x01(\tR\x10geohashFieldNameB\0\x12j\n\x12geometryProperties\x18\x05\x20\
    \x01(\x0b28.esriPBuffer.FeatureCollectionPBuffer.GeometryPropertiesR\x12\
    geometryPropertiesB\0\x12R\n\nserverGens\x18\x06\x20\x01(\x0b20.esriPBuf\
    fer.FeatureCollectionPBuffer.ServerGensR\nserverGensB\0\x12X\n\x0cgeomet\
    ryType\x18\x07\x20\x01(\x0e22.esriPBuffer.FeatureCollectionPBuffer.Geome\
    tryTypeR\x0cgeometryTypeB\0\x12d\n\x10spatialReference\x18\x08\x20\x01(\
    \x0b26.esriPBuffer.FeatureCollectionPBuffer.SpatialReferenceR\x10spatial\
    ReferenceB\0\x126\n\x15exceededTransferLimit\x18\t\x20\x01(\x08R\x15exce\
    ededTransferLimitB\0\x12\x14\n\x04hasZ\x18\n\x20\x01(\x08R\x04hasZB\0\
    \x12\x14\n\x04hasM\x18\x0b\x20\x01(\x08R\x04hasMB\0\x12O\n\ttransform\
    \x18\x0c\x20\x01(\x0b2/.esriPBuffer.FeatureCollectionPBuffer.TransformR\
    \ttransformB\0\x12E\n\x06fields\x18\r\x20\x03(\x0b2+.esriPBuffer.Feature\
    CollectionPBuffer.FieldR\x06fieldsB\0\x12E\n\x06values\x18\x0e\x20\x03(\
    \x0b2+.esriPBuffer.FeatureCollectionPBuffer.ValueR\x06valuesB\0\x12K\n\
    \x08features\x18\x0f\x20\x03(\x0b2-.esriPBuffer.FeatureCollectionPBuffer\
    .FeatureR\x08featuresB\0:\0\x1a'\n\x0bCountResult\x12\x16\n\x05count\x18\
    \x01\x20\x01(\x04R\x05countB\0:\0\x1a\xb9\x01\n\x0fObjectIdsResult\x12.\
    \n\x11objectIdFieldName\x18\x01\x20\x01(\tR\x11objectIdFieldNameB\0\x12R\
    \n\nserverGens\x18\x02\x20\x01(\x0b20.esriPBuffer.FeatureCollectionPBuff\
    er.ServerGensR\nserverGensB\0\x12\x20\n\tobjectIds\x18\x03\x20\x03(\x04R\
    \tobjectIdsB\x02\x10\x01:\0\x1a\xab\x02\n\x0bQueryResult\x12]\n\rfeature\
    Result\x18\x01\x20\x01(\x0b23.esriPBuffer.FeatureCollectionPBuffer.Featu\
    reResultH\0R\rfeatureResultB\0\x12W\n\x0bcountResult\x18\x02\x20\x01(\
    \x0b21.esriPBuffer.FeatureCollectionPBuffer.CountResultH\0R\x0bcountResu\
    ltB\0\x12W\n\tidsResult\x18\x03\x20\x01(\x0b25.esriPBuffer.FeatureCollec\
    tionPBuffer.ObjectIdsResultH\0R\tidsResultB\0B\t\n\x07Results:\0\"\xc0\
    \x01\n\x0cGeometryType\x12\x19\n\x15esriGeometryTypePoint\x10\0\x12\x1e\
    \n\x1aesriGeometryTypeMultipoint\x10\x01\x12\x1c\n\x18esriGeometryTypePo\
    lyline\x10\x02\x12\x1b\n\x17esriGeometryTypePolygon\x10\x03\x12\x1e\n\
    \x1aesriGeometryTypeMultipatch\x10\x04\x12\x18\n\x14esriGeometryTypeNone\
    \x10\x7f\x1a\0\"\xd1\x02\n\tFieldType\x12\x1d\n\x19esriFieldTypeSmallInt\
    eger\x10\0\x12\x18\n\x14esriFieldTypeInteger\x10\x01\x12\x17\n\x13esriFi\
    eldTypeSingle\x10\x02\x12\x17\n\x13esriFieldTypeDouble\x10\x03\x12\x17\n\
    \x13esriFieldTypeString\x10\x04\x12\x15\n\x11esriFieldTypeDate\x10\x05\
    \x12\x14\n\x10esriFieldTypeOID\x10\x06\x12\x19\n\x15esriFieldTypeGeometr\
    y\x10\x07\x12\x15\n\x11esriFieldTypeBlob\x10\x08\x12\x17\n\x13esriFieldT\
    ypeRaster\x10\t\x12\x15\n\x11esriFieldTypeGUID\x10\n\x12\x19\n\x15esriFi\
    eldTypeGlobalID\x10\x0b\x12\x14\n\x10esriFieldTypeXML\x10\x0c\x1a\0\"\
    \x8f\x04\n\x07SQLType\x12\x11\n\rsqlTypeBigInt\x10\0\x12\x11\n\rsqlTypeB\
    inary\x10\x01\x12\x0e\n\nsqlTypeBit\x10\x02\x12\x0f\n\x0bsqlTypeChar\x10\
    \x03\x12\x0f\n\x0bsqlTypeDate\x10\x04\x12\x12\n\x0esqlTypeDecimal\x10\
    \x05\x12\x11\n\rsqlTypeDouble\x10\x06\x12\x10\n\x0csqlTypeFloat\x10\x07\
    \x12\x13\n\x0fsqlTypeGeometry\x10\x08\x12\x0f\n\x0bsqlTypeGUID\x10\t\x12\
    \x12\n\x0esqlTypeInteger\x10\n\x12\x17\n\x13sqlTypeLongNVarchar\x10\x0b\
    \x12\x18\n\x14sqlTypeLongVarbinary\x10\x0c\x12\x16\n\x12sqlTypeLongVarch\
    ar\x10\r\x12\x10\n\x0csqlTypeNChar\x10\x0e\x12\x13\n\x0fsqlTypeNVarchar\
    \x10\x0f\x12\x10\n\x0csqlTypeOther\x10\x10\x12\x0f\n\x0bsqlTypeReal\x10\
    \x11\x12\x13\n\x0fsqlTypeSmallInt\x10\x12\x12\x11\n\rsqlTypeSqlXml\x10\
    \x13\x12\x0f\n\x0bsqlTypeTime\x10\x14\x12\x14\n\x10sqlTypeTimestamp\x10\
    \x15\x12\x15\n\x11sqlTypeTimestamp2\x10\x16\x12\x12\n\x0esqlTypeTinyInt\
    \x10\x17\x12\x14\n\x10sqlTypeVarbinary\x10\x18\x12\x12\n\x0esqlTypeVarch\
    ar\x10\x19\x1a\0\"7\n\x15QuantizeOriginPostion\x12\r\n\tupperLeft\x10\0\
    \x12\r\n\tlowerLeft\x10\x01\x1a\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
